---
name: sensei:generate-specs
description: Generate specifications from implementation code
argument-hint: "[--all | --api | --components | --schema | --env]"
allowed-tools: [Read, Write, Edit, Glob, Grep, Bash]
---

<objective>
Analyze your codebase and generate specifications from what's actually implemented.

Turns implementation code into documentation:
- API routes → OpenAPI/Swagger specs
- React/Vue/Svelte components → Component documentation
- Database models → Schema documentation
- Environment variables → .env documentation

Run after building significant features or when you need up-to-date documentation.
</objective>

<execution_context>
@~/.claude/buildsensei/workflows/generate-specs.md
@~/.claude/buildsensei/templates/spec/openapi.md
@~/.claude/buildsensei/templates/spec/component.md
@~/.claude/buildsensei/templates/spec/schema.md
@~/.claude/buildsensei/templates/spec/env.md
</execution_context>

<context>
$ARGUMENTS - Scope filter: --all (default), --api, --components, --schema, --env

Project context:
@.planning/PROJECT.md (if exists)
@CLAUDE.md (if exists)
@package.json (for framework detection)
</context>

<process>

<step name="parse_args">
## Parse Arguments

Determine scope from $ARGUMENTS:

| Argument | Scope |
|----------|-------|
| (none) | all |
| --all | all |
| --api | api only |
| --components | components only |
| --schema | schema only |
| --env | env only |

Multiple flags can be combined: `--api --schema`
</step>

<step name="detect_stack">
## Detect Project Stack

```bash
# Read package.json for framework detection
cat package.json 2>/dev/null
```

Identify:
- **Framework:** Next.js, Express, Fastify, Hono, etc.
- **UI Library:** React, Vue, Svelte, etc.
- **ORM:** Prisma, Drizzle, TypeORM, Mongoose, etc.
- **API Style:** App Router, Pages Router, REST routes, etc.

This determines which detection patterns to use.
</step>

<step name="create_directories">
## Create Output Directories

```bash
mkdir -p docs/spec/api
mkdir -p docs/spec/components/ui
mkdir -p docs/spec/components/form
mkdir -p docs/spec/components/layout
mkdir -p docs/spec/components/data-display
mkdir -p docs/spec/components/feedback
mkdir -p docs/spec/components/navigation
mkdir -p docs/spec/data
```
</step>

<step name="generate_api" condition="scope includes api">
## Generate API Specifications

### Find API Routes

Based on detected framework:

**Next.js App Router:**
```bash
find app -name "route.ts" -o -name "route.js" 2>/dev/null
```

**Next.js Pages Router:**
```bash
find pages/api -type f \( -name "*.ts" -o -name "*.js" \) 2>/dev/null
```

**Express/Fastify/Hono:**
```bash
grep -rl "router\.\(get\|post\|put\|patch\|delete\)" src/ 2>/dev/null
```

### Analyze Routes

For each route file found:
1. Read the file
2. Extract HTTP methods (GET, POST, PUT, PATCH, DELETE)
3. Extract path from file location or route definition
4. Extract request body schema (from validation or TypeScript types)
5. Extract response shapes (from return/response calls)
6. Identify auth requirements (middleware presence)
7. Extract path and query parameters

### Generate OpenAPI Specs

Group routes by resource (e.g., /api/users/* → users.yaml)

For each resource group, generate:
```yaml
# docs/spec/api/{resource}.yaml
openapi: 3.0.0
info:
  title: {Resource} API
  version: 1.0.0
paths:
  {path}:
    {method}:
      summary: {inferred_summary}
      operationId: {operation_id}
      parameters: {extracted_params}
      requestBody: {extracted_body}
      responses: {extracted_responses}
components:
  schemas:
    {extracted_schemas}
```

### Create Index

Generate combined spec:
```yaml
# docs/spec/api/index.yaml
openapi: 3.0.0
info:
  title: {project_name} API
  version: {version}
  description: |
    Auto-generated API specification.
    Generated by BuildSensei from source code analysis.
# ... combined paths and schemas
```
</step>

<step name="generate_components" condition="scope includes components">
## Generate Component Specifications

### Find Components

```bash
# React components (capitalized .tsx/.jsx files)
find src components -name "[A-Z]*.tsx" -o -name "[A-Z]*.jsx" 2>/dev/null

# Vue components
find src components -name "*.vue" 2>/dev/null

# Svelte components
find src -name "*.svelte" 2>/dev/null
```

### Analyze Components

For each component:
1. Extract props/properties interface
2. Extract default values
3. Extract events/emits
4. Extract slots (Vue/Svelte)
5. Extract JSDoc/comments for descriptions
6. Categorize (UI, Form, Layout, etc.)

### Generate Component Docs

For each component:
```markdown
# docs/spec/components/{category}/{ComponentName}.spec.md

# {ComponentName}

> {description}

**Location:** `{file_path}`
**Category:** {category}

## Props

| Prop | Type | Default | Required | Description |
|------|------|---------|----------|-------------|
{props_table}

## Events

| Event | Payload | Description |
|-------|---------|-------------|
{events_table}

## Examples

{usage_examples}
```

### Create Index

```markdown
# docs/spec/components/index.md
# Component Library

{components_grouped_by_category}
```
</step>

<step name="generate_schema" condition="scope includes schema">
## Generate Schema Specifications

### Detect ORM and Find Schema

**Prisma:**
```bash
cat prisma/schema.prisma 2>/dev/null
```

**Drizzle:**
```bash
cat src/db/schema.ts src/schema.ts 2>/dev/null
find src -name "*.schema.ts" 2>/dev/null
```

**TypeORM:**
```bash
find src -name "*.entity.ts" 2>/dev/null
```

**Mongoose:**
```bash
find src -name "*.model.ts" 2>/dev/null
```

### Parse Schema

For each model/table:
1. Extract table name
2. Extract fields with types
3. Extract relationships
4. Extract indexes and constraints
5. Extract default values

### Generate Schema Doc

```markdown
# docs/spec/data/schema.md
# Database Schema

## Entity Relationship Diagram

{text_based_erd}

## Models

### {ModelName}

| Field | Type | Nullable | Default | Description |
|-------|------|----------|---------|-------------|
{fields_table}

#### Relationships
{relationships}

#### Indexes
{indexes}
```
</step>

<step name="generate_env" condition="scope includes env">
## Generate Environment Documentation

### Find Environment Variables

**From .env files:**
```bash
cat .env.example .env.local 2>/dev/null | grep -E "^[A-Z_]+="
```

**From code:**
```bash
grep -rh "process\.env\.[A-Z_]+" src/ --include="*.ts" --include="*.js" 2>/dev/null | \
  grep -oE "process\.env\.[A-Z_]+" | sort -u
```

**From validation schemas:**
```bash
cat src/env.ts src/lib/env.ts 2>/dev/null
```

### Analyze and Categorize

Group variables by category:
- Database (DATABASE_URL, DB_*)
- Authentication (JWT_*, AUTH_*, SESSION_*)
- External Services (STRIPE_*, SENDGRID_*, AWS_*)
- Application (NODE_ENV, PORT, APP_*)
- Feature Flags (ENABLE_*, FEATURE_*)
- Client-Side (NEXT_PUBLIC_*, VITE_*)

### Generate Documentation

```markdown
# docs/spec/env.md
# Environment Variables

## Quick Start
{setup_instructions}

## Variable Reference

### Database
{database_vars_table}

### Authentication
{auth_vars_table}

...
```

### Update .env.example

Add any discovered variables not in .env.example:

```bash
# Append new variables
echo "# Discovered by BuildSensei" >> .env.example
echo "NEW_VARIABLE=\"\"  # TODO: Add value" >> .env.example
```
</step>

<step name="update_context">
## Update Context Files

### Update CLAUDE.md (if exists)

Add documentation references:
```markdown
## Documentation

Generated specifications:
- [API Spec](./docs/spec/api/index.yaml) - OpenAPI 3.0
- [Components](./docs/spec/components/index.md) - Component library
- [Schema](./docs/spec/data/schema.md) - Database models
- [Environment](./docs/spec/env.md) - Configuration
```

### Update references.md (if exists)

Add internal documentation links.
</step>

<step name="commit">
## Commit Generated Specifications

```bash
git add docs/spec/
git add .env.example 2>/dev/null
git add CLAUDE.md references.md 2>/dev/null

# Check if there are changes to commit
if ! git diff --cached --quiet; then
  git commit -m "docs(spec): Generate specifications from codebase

Generated:
- API: {endpoint_count} endpoints
- Components: {component_count} components
- Schema: {model_count} models
- Environment: {var_count} variables

Co-Authored-By: BuildSensei <noreply@buildsensei.dev>"
fi
```
</step>

<step name="report">
## Report Results

```markdown
## Specification Generation Complete

### Summary

| Category | Output | Count |
|----------|--------|-------|
| API | docs/spec/api/ | {N} endpoints |
| Components | docs/spec/components/ | {N} components |
| Schema | docs/spec/data/schema.md | {N} models |
| Environment | docs/spec/env.md | {N} variables |

### Files Generated

{list_of_generated_files}

### Notes

{any_warnings_or_todos}

---

To regenerate after changes:
`/sensei:generate-specs`

To regenerate specific category:
`/sensei:generate-specs --api`
```
</step>

</process>

<success_criteria>
- [ ] Project stack detected correctly
- [ ] Requested spec types generated
- [ ] Output files valid and readable
- [ ] Context files updated with references
- [ ] Changes committed
- [ ] Report displayed with counts
</success_criteria>
